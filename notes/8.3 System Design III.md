# 8.3 System Design II - Advanced

## GFS

**How to store small files on disk?**
- Metadata
    - file info: name, created, size, etc.
    - block index
        ```
        block 11 -> disk_offset
        block 25 -> disk_offset
        block 37 -> disk_offset
        ```
- Blocks
    - find the block according to the block index
    - 1 block = `1024 Byte`

**How to store big file?**
- Chunks
    - if the file is big, there will be too many blocks
    - we combine the small blocks into bigger chunks
    - 1 chunk = `64 MB (65,536 blocks)`
    - chunk index:
        ```
        chunk 10 -> disk_offset
        chunk 25 -> disk_offset
        chunk 33 -> disk_offset
        ```
- The con for this design is for small files, space will be wasted

**How to store huge file?**
- Master Server
    - if the file is huge, we need multiple machines to store the data
    - we create a Master server and multiple chunk servers
    - stores chunk index and chunk server mapping
        ```
        chunk 10 -> chunk server 1
        chunk 25 -> chunk server 2
        chunk 33 -> chunk server 1
        chunk 48 -> chunk server 2
        chunk 69 -> chunk server 3
        ```
    - file metadata will be stored in Master server as well
- Chunk Servers
    - store chunk index
        ```
        chunk server 1
            chunk 10 -> disk_offset
            chunk 33 -> disk_offset
        chunk server 2
            chunk 25 -> disk_offset
            chunk 48 -> disk_offset
        chunk server 3
            chunk 69 -> disk_offset
        ```
    - whenever file changes, chunk server doesn't have to inform the Master, Master only store the chunkIndex-to-chunkServer mapping

**How to detect file corruption?**
- Checksum
    - calculate a checksum for each file block
    - every time we read a block, validate checksum
    - 1 checksum = `32 bit`
    - `1 TB` file only need `1 TB / 64KB * 32 bit = 64 MB`, easy to store in memory

**How to recover when a chunk is lost or corrupted?**
- Replication
    - create 3 replicas for each chunk server
    - Master stores chunk index to a list of chunk servers
        ```
        chunk 03 -> CS1, CS4, CS7
        chunk 27 -> CS2, CS5, CS7
        chunk 38 -> CS2, CS6, CS7
        ```
- How to select the replica
    - low hardware usage
    - limit new data writes (prevent hot spot)
    - cross data center (e.g. put 2 CS in CA, 1 in WA)
- How to recover from chunk corruption?
    - let's say `chunk 03` corrupted in `Chunk Server 4`
    - CS4 ask Master, which chunk servers has `chunk 03`?
    - Master replies, CS4 and CS7 has `chuck 03`
    - CS4 then establish connection to the closest one (CS3) and get `chuck 03`

**How to recover when a chunk server is dead**
- Heart Beat
    - each chunk server ping Master about their liveness
    - `Master` stores the chuck server index and a timestamp
    - if CS4 does not send heart beat for a long time (check timestamp), `Master` knows that CS4 is dead
- Recover Processor
    - when `Master` detects error in the chuck server mapping (# of CS < 3), it will add it to the recovery process
    - the recovery processor will initiate the recovery process
    - the less the CS is alive, the higher the priority to recover

**How to resolve hot spot**
- Hot Spot Load Balancing
    - Master stores chunk status ```chuck id -> access frequency```
    - Master also stores chunk server status
        ```
        CS1, free space = 21%, free bandwidth = 15%
        CS3, free space = 60%, free bandwidth = 30%
        ```
    - If the CS or a replica is too busy, we can create more CS or balance it out
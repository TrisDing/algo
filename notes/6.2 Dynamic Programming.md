# Dynamic Programming

> Dynamic Programming is a technique in computer programming that helps to efficiently solve a class of problems that have overlapping subproblems and optimal substructure property.

- **Optimal Substructure**: the solution to a given optimization problem can be obtained by the combination of optimal solutions to its sub-problems. Such optimal substructures are usually described by means of "_recursion_".
- **Overlapping Subproblems**: the space of sub-problems must be small, that is, any recursive algorithm solving the problem should solve the same sub-problems over and over, rather than generating new sub-problems. If a problem can be solved by combining optimal solutions to non-overlapping sub-problems, the strategy is called _"divide and conquer"_ instead.

This can be achieved in either of two ways:
1. **Top-down**: Recursion + Memo
2. **Bottom-up**: Iteration + DP Table (states)

### Fibonacci sequence

**Top-down**
```
                            _________________f(5)________________
                           /                                     \
                  _______f(4)______                       _______f(3)_
                 /                 \                     /            \
        _______f(3)_             __f(2)_             __f(2)_          f(1)
       /            \           /       \           /       \
   __f(2)_          f(1)      f(1)      f(1)      f(1)      f(1)
  /       \
f(1)      f(1)
```

```py
# Recursion
def fib(N):
    if N < 2: return N
    return fib(N-1) + fib(N-2)

# Space Optimized Version (Memo)
memo = {}
def fib(N):
    if N < 2: return N
    if N not in memo:
        memo[N] = fib(N-1) + fib(N-2)
    return memo[N]
```

**Bottom-up**
```
f(0) f(1) f(2) f(3) f(4) f(5)
  1    2    3    5    8   13
--------------------------->
```

```py
# Dynamic Programming
def fib(N):
    """
    dp(N) = {
        N, N < 2
        dp(N-1) + dp(N-2), N >= 2
    }
    """
    if N < 2: return N
    dp = [0] * (N+1)
    dp[0] = 0
    dp[1] = 1
    for i in range(2, N+1):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[-1]

# Space Optimized Version (Reduce States)
def fib(self):
    if N < 2: return N
    f, f1, f2 = 0, 0, 1
    for i in range(N):
        f = f1 + f2
        f2 = f1
        f1 = f
    return f
```

### DP Framework

1. Determine the DP table and the meaning of it's index
2. Write the status transfer formula
3. How to initialize the DP table
4. Determine the traverse order
5. Give some test cases to validate the DP table

### 0/1 Knapsack Problem

Given weights and values of n items, put these items in a knapsack of capacity W to get the maximum total value in the knapsack. You cannot break an item, either pick the complete item or donâ€™t pick it (0-1 property).

```py
def knapsack(W, weight, value):
    """
    dp[i][j] means when we put item i (or not put) into a knapsack of capacity j,
    the maximum total value currently in the knapsack.

    dp[i][j] = {
        0       , i == 0 and j <  weight[0] (not enough space to put first item)
        value[0], i == 0 and j >= weight[0] (has enough space to put first item)

        0, j == 0 (no space available)

        dp[i-1][j], i > 0 and j < weight[i] (not enough space to put item i)

        max(
            dp[i-1][j], (choose not to put item i)
            dp[i-1][j - weight[i]] + value[i] (choose to put item i)
        ), i > 0 and j >= weight[i] (has enough space to put item i)
    }
    """
    N = len(weight)

    dp = [[0] * (W+1) for _ in range(N)]

    # Initialize DP
    for i in range(N):
        dp[i][0] = 0 # no space available

    for j in range(1, W+1):
        if j < weight[0]: # not enough space to put first item
            dp[0][j] = 0
        else: # has enough space to put first item
            dp[0][j] = value[0]

    print(dp)
    """
       0  1  2  3  4
    1  0 15 15 15 15
    2  0  .  .  .  .
    3  0  .  .  .  .
    """

    for i in range(1, N):
        for j in range(1, W+1):
            if j < weight[i]: # not enough space to put item i
                dp[i][j] = dp[i-1][j] # total value is not changed
            else: # has enough space to put item i
                # make a choose: "put item i" or "not put item i", choose the max value
                dp[i][j] = max(dp[i-1][j], dp[i-1][j - weight[i]] + value[i])

    print(dp)
    """
       0  1  2  3  4
    1  0 15 15 15 15
    2  0 15 15 20 35
    3  0 15 15 20 35
    """

    return dp[N-1][W]

ans = knapsack(4, [1,3,4], [15,20,30])
print(ans) # 35
```

Optimization: Status Compression (Rolling Array)

```py
# We know that dp[i][j] only depends on its previous layer dp[i-1][j]
dp[i][j] = max(dp[i-1][j], dp[i-1][j - weight[i]] + value[i])

# We can copy the values from dp[i-1][j] to dp[i][j]
dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i])

# Thus the DP array can be "compressed" into one dimensional
dp[j] = max(dp[j], dp[j - weight[i]] + value[i])

# To ensure we pick each item only once, we need to traverse j backwards from W to weight[i]
dp = [0] * (W+1)
for i in range(N):
    for j in range(W, weight[i] - 1, -1):
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
```

## Leetcode Problems

Basics
- [509. Fibonacci Number](https://leetcode.com/problems/fibonacci-number/)
- [70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/)
- [746. Min Cost Climbing Stairs](https://leetcode.com/problems/min-cost-climbing-stairs/)

Unique Paths
- [62. Unique Paths](https://leetcode.com/problems/unique-paths/)
- [63. Unique Paths II](https://leetcode.com/problems/unique-paths-ii/)
- [980. Unique Paths III](https://leetcode.com/problems/unique-paths-iii/)
- [343. Integer Break](https://leetcode.com/problems/integer-break/)
- [96. Unique Binary Search Trees](https://leetcode.com/problems/unique-binary-search-trees/)
- [120. Triangle](https://leetcode.com/problems/triangle/)

0/1 Knapsack
- [416. Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/)
- [1049. Last Stone Weight II](https://leetcode.com/problems/last-stone-weight-ii/)
- [494. Target Sum](https://leetcode.com/problems/target-sum/)
- [474. Ones and Zeroes](https://leetcode.com/problems/ones-and-zeroes/)

Complete Knapsack
- [518. Coin Change 2](https://leetcode.com/problems/coin-change-2/)
- [377. Combination Sum IV](https://leetcode.com/problems/combination-sum-iv/)
- [322. Coin Change](https://leetcode.com/problems/coin-change/)
- [279. Perfect Squares](https://leetcode.com/problems/perfect-squares/)

House Robber
- [198. House Robber](https://leetcode.com/problems/house-robber/)
- [213. House Robber II](https://leetcode.com/problems/house-robber-ii/)
- [337. House Robber III](https://leetcode.com/problems/house-robber-iii/)

Buy and Sell Stocks
- [121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)
- [122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)
- [123. Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/)
- [188. Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/)
- [309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)
- [714. Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

Sub Array / Sub Subsequence
- [300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/)
- [674. Longest Continuous Increasing Subsequence](https://leetcode.com/problems/longest-continuous-increasing-subsequence/)
- [718. Maximum Length of Repeated Subarray](https://leetcode.com/problems/maximum-length-of-repeated-subarray/)
- [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)
- [1035. Uncrossed Lines](https://leetcode.com/problems/uncrossed-lines/)
- [53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)
- [152. Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/description/)
- [392. Is Subsequence](https://leetcode.com/problems/is-subsequence/)
- [115. Distinct Subsequences](https://leetcode.com/problems/distinct-subsequences/)
- [583. Delete Operation for Two Strings](https://leetcode.com/problems/delete-operation-for-two-strings/)
- [72. Edit Distance](https://leetcode.com/problems/edit-distance/)
- [647. Palindromic Substrings](https://leetcode.com/problems/palindromic-substrings/)
- [516. Longest Palindromic Subsequence](https://leetcode.com/problems/longest-palindromic-subsequence/)
- [416. Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/)
# Bloom Filter

> A Bloom filter is a space-efficient probabilistic data structure that is used to test whether an element is a member of a set. The price for efficiency is that it is probabilistic in nature that means, there might be some False Positive results.

```
INITIAL BITS
0 0 0 0 0 0 0 0 0 0

INSERT X {0, 3, 7}
(1) 0 0 (1) 0 0 0 (1) 0 0

INSERT Y {2, 3, 4}
1 0 (1) (1) (1) 0 0 1 0 0

SEARCH Z {1, 4, 7}
1 (0) 1 1 (1) 0 0 (1) 0 0 <== Probably Present

SEARCH W {1, 5, 6}
1 (0) 1 1 1 (0) (0) 1 0 0 <== Definitely NOT Present
```

## Properties
- Unlike a standard hash table, a Bloom filter of a fixed size can represent a set with an arbitrarily large number of elements.
- Bloom filters never generate false negative result
- Adding an element never fails. However, the false positive rate increases steadily as elements are added until all bits in the filter are set to 1, at which point all queries yield a positive result.
- Deleting elements from filter is not possible because, if we delete a single element by clearing bits at indices generated by k hash functions, it might cause deletion of few other elements.

# LRU Cache

> Discards the least recently used items first. This algorithm requires keeping track of what was used when, which is expensive if one wants to make sure the algorithm always discards the least recently used item.

```
      A    B    C    D    E    F    C    G
--------------------------------------------
[ ]  [A]  [B]  [C]  [D]  [E]  [F]  [C]  [G]
[ ]  [ ]  [A]  [B]  [C]  [D]  [E]  [F]  [C]
[ ]  [ ]  [ ]  [A]  [B]  [C]  [D]  [E]  [F]
[ ]  [ ]  [ ]  [ ]  [A]  [B]  [C]  [D]  [E]
[ ]  [ ]  [ ]  [ ]  [ ]  [A]  [B]  [B]  [D]
--------------------------------------------
                              [A]       [B]
```

## Properties
- Native Implementation: Hash Table + Doubly LinkedList
- Python API Implementation: `collections.OrderedDict()`
- O(1) lookup
- O(1) update

```py
class DoublyLinkedNode:
    def __init__(self, key=0, value=0):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None

class LRUCache:

    def __init__(self, capacity: int):
        self.cache = {} # key -> DoublyLinkedNode
        self.head = DoublyLinkedNode()
        self.tail = DoublyLinkedNode()
        self.head.next = self.tail
        self.tail.prev = self.head
        self.capacity = capacity
        self.size = 0

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        # if key exists, locate node in cache, then move to head
        node = self.cache[key] # key is now most recently used
        self.moveToHead(node)
        return node.value

    def put(self, key: int, value: int) -> None:
        if key not in self.cache:
            node = DoublyLinkedNode(key, value)
            self.cache[key] = node
            self.addToHead(node)
            self.size += 1
            if self.size > self.capacity:
                # drop least recently used (tail)
                removed = self.removeTail()
                self.cache.pop(removed.key)
                self.size -= 1
        else:
            node = self.cache[key]
            node.value = value
            self.moveToHead(node)

    def addToHead(self, node: DoublyLinkedNode) -> None:
        node.prev = self.head
        node.next = self.head.next
        self.head.next.prev = node
        self.head.next = node

    def removeNode(self, node: DoublyLinkedNode) -> None:
        node.prev.next = node.next
        node.next.prev = node.prev

    def moveToHead(self, node: DoublyLinkedNode) -> None:
        self.removeNode(node)
        self.addToHead(node)

    def removeTail(self) -> DoublyLinkedNode:
        node = self.tail.prev
        self.removeNode(node)
        return node
```

## Leetcode Problems
- [146. LRU Cache](https://leetcode.com/problems/lru-cache/)

# The Top-K Problem

> Given an integer array `nums` and an integer `k`, return the `k` most frequent elements.

## Sort
```py
def topKFrequent(nums: List[int], k: int) -> List[int]:
    if k >= len(nums): return nums
    """
    O(N log N) at best
    """
    nums.sort()
    return nums[:k+1]
```

## Heap
```py
import collections
import heapq

def topKFrequent(nums: List[int], k: int) -> List[int]:
    if k >= len(nums): return nums
    """
    O(N log k)
    """
    frequency = collections.Counter(nums) # O(N)
    return heapq.nlargest(k, frequency.keys, key=frequency.get) # O(N log k)
```

## Quick Select
```py
import collections
import random

def topKFrequent(nums: List[int], k: int) -> List[int]:
    if k >= len(nums): return nums
    """
    O(N) on average
    O(N^2) worse case (pivot is selected at either nums[0] or nums[n-1])
    """
    frequency = collections.Counter(nums)
    keys = list(frequency.keys())
    n = len(keys)

    def partition(left, right, pivot) -> int:
        pivot_frequency = frequency[keys[pivot]]
        # 1. move pivot to end
        keys[pivot], keys[right] = keys[right], keys[pivot]
        # 2. move all less frequent elements to the left
        store_index = left
        for i in range(left, right):
            if frequency[keys[i]] < pivot_frequency:
                keys[store_index], keys[i] = keys[i], keys[store_index]
                store_index += 1
        # 3. move pivot to its final place
        keys[right], keys[store_index] = keys[store_index], keys[right]
        return store_index

    def quickSelect(left, right, k_smallest) -> None:
        if left == right: return
        pivot = random.randint(left, right) # prevent worse case
        pivot = partition(left, right, pivot)
        if k_smallest < pivot:
            quickSelect(left, pivot - 1, k_smallest)
        elif k_smallest > pivot:
            quickSelect(pivot + 1, right, k_smallest)
        # k_smallest == pivot: return

    # kth top frequent element is (n - k)th less frequent.
    # Do a partial sort: from less frequent to the most frequent, till
    # (n - k)th less frequent element takes its place (n - k) in a sorted array.
    # All element on the left are less frequent.
    # All the elements on the right are more frequent.
    quickSelect(0, n - 1, n - k)
    return keys[n - k:]
```

## Bucket Sort
```py
import collections

def topKFrequent(nums, k):
    if k >= len(nums): return nums
    """
    O(N) strictly (space exchange time)
    """
    buckets = [[] for _ in range(len(nums) + 1)] # big space
    frequency = collections.Counter(nums)
    for num, freq in frequency.items():
        buckets[freq].append(num)
    flatten = [num for bucket in buckets for num in bucket]
    return flatten[::-1][:k]
```
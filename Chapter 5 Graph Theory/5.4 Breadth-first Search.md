# Breadth-first Search (BFS)

> Breadth-first search is an algorithm for searching a tree data structure for a node that satisfies a given property. It starts at the tree root and explores all nodes at the present depth prior to moving on to the nodes at the next depth level.

## The Algorithm

- Pick any node, visit the adjacent unvisited vertex, mark it as visited, process it, and insert it in a queue.
- If there are no remaining adjacent vertices left, remove the first vertex from the queue.
- Repeat step 1 and step 2 until the queue is empty or the desired node is found.

```py
queue = collections.deque()
visited = set()

def bfs(node):
    queue.append(node)
    visited.add(node)

    # Loop until queue is empty
    while queue:
        # get current node from queue
        curr = queue.popleft()

        # process current node
        print(curr.val)

        # process neighbors if not visited
        for neighbour in graph[curr]:
            if neighbour not in visited:
                # add to visited
                visited.append(neighbour)
                # add to queue
                queue.append(neighbour)
```

## Time Complexity

Since all of â€‹the nodes and vertices are visited, the time complexity for BFS on a graph is `O(V + E)`; where `V` is the number of vertices and `E` is the number of edges.

## BFS Applications

### Level Order
```py
def levelOrder(root):
    queue = collections.deque([root])
    visited = set([root])
    res = []

    while queue:
        # process all nodes from the current level
        level_nodes = []
        for _ in range(len(queue)):
            # get current node from queue
            node = queue.popleft()

            # process current node
            level_nodes.append(node.val)

            # process children if not visited
            if node.children:
                for child in node.children:
                    if child not in visited:
                        visited.add(child)
                        queue.append(child)

        res.append(level_nodes)

    return res
```

### Shortest Path
```py
def shortestPath(start, target):
    queue = collections.deque([start])
    visited = set([start])
    step = 0

    # Loop until queue is empty
    while queue:
        # spread the search from the current level
        for _ in range(len(queue)):
            # get current node from queue
            node = queue.popleft()

            # see if we reach the target
            if node is target:
                return step

            # process children
            if node.children:
                for child in node.children:
                    if child not in visited:
                        queue.append(child)
                        visited.add(child)

        step += 1

    return 0 # not found
```

### Bidirectional BFS
```py
def biBfs(source, target):
    sourceQueue = collections.deque([source])
    targetQueue = collections.deque([target])
    visited = set([source])
    step = 0

    while sourceQueue and targetQueue:
        # choose the smaller queue to spread
        if len(sourceQueue) > len(targetQueue):
            sourceQueue, targetQueue = targetQueue, sourceQueue

        for _ in range(len(sourceQueue)):
            node = sourceQueue.popleft()

            # source and target meet
            if node in targetQueue:
                return step

            # process children
            if node.children:
                for child in node.children:
                    if child not in visited:
                        sourceQueue.append(child)
                        visited.add(child)
        step += 1

    return 0 # not found
```

### Multi Threaded BFS
```py
from concurrent import futures

def crawl(self, startUrl: str, htmlParser: 'HtmlParser') -> List[str]:
    hostname = lambda url: url.split('/')[2]
    visited = set()
    visited.add(startUrl)

    with futures.ThreadPoolExecutor(max_workers=16) as executor:
        tasks = deque([executor.submit(htmlParser.getUrls, startUrl)])
        while tasks:
            for url in tasks.popleft().result():
                if url not in visited and hostname(startUrl) == hostname(url):
                    visited.add(url)
                    tasks.append(executor.submit(htmlParser.getUrls, url))

    return list(visited)
```

- [111. Minimum Depth of Binary Tree](https://leetcode.com/problems/minimum-depth-of-binary-tree/)
- [515. Find Largest Value in Each Tree Row](https://leetcode.com/problems/find-largest-value-in-each-tree-row/)
- [127. Word Ladder](https://leetcode.com/problems/word-ladder/)
- [126. Word Ladder II](https://leetcode.com/problems/word-ladder-ii/)
- [752. Open the Lock](https://leetcode.com/problems/open-the-lock/)
- [433. Minimum Genetic Mutation](https://leetcode.com/problems/minimum-genetic-mutation/)
- [854. K-Similar Strings](https://leetcode.com/problems/k-similar-strings/)
- [529. Minesweeper](https://leetcode.com/problems/minesweeper/)
- [773. Sliding Puzzle](https://leetcode.com/problems/sliding-puzzle/)

## Graph Traversal

Given edges, construct graph
```py
edges: List[List[int]] = [[0,1],[1,2],[2,0]]

graph = collections.defaultdict(list) # or defaultdict(set)
for u, v in edges:
    graph[u].append(v) # u -> v
    graph[v].append(u) # v -> u, undirected (bi-directional) add this line
```

Given a directed acyclic graph (DAG) of `n` nodes labeled from `0` to `n-1`, find all possible paths from node `start` to node `end` and return them in any order.
```py
def allPathsSourceTarget(self, graph: dict[int, list[int]], start: int, end: int) -> List[List[int]]:
    n = len(graph)
    res = []

    startPath = [start]
    queue = collections.deque([startPath])

    while queue:
        path = queue.popleft()
        u = path[-1]
        for v in graph[u]:
            currentPath = path[:]
            currentPath.append(v)
            if v == end:
                res.append(currentPath)
            else:
                queue.append(currentPath)

    return res
```

Given a **undirected graph** (or bi-directional graph) with `n` vertices labeled from `0` to `n-1`. Determine if there is a valid path that exists from vertex `start` to vertex `end`.
```py
def validPath(self, n: int, graph: dict[int, list[int]], start: int, end: int) -> bool:
    visited = set()
    queue = collections.deque([start])

    while queue:
        u = queue.popleft()
        if u == end:
            return True
        visited.add(u)
        for v in graph[u]:
            if v not in visited:
                queue.append(v)

    return False
```

Given a directed graph of `n` nodes labeled from `0` to `n-1`, Return an array answer of length n, where each `answer[x]` is the length of the shortest path from node `0` to node `x`, or -1 if such a path does not exist.
```py
def lengthShortestPaths(self, n: int, graph: dict[int, set[int]], start: int, end: int) -> List[int]:
    answer = [math.inf] * n
    count = -1
    queue = collections.deque([0])

    while queue:
        count += 1
        for _ in range(len(queue)):
            u = queue.popleft()
            answer[u] = min(answer[u], count)

            for v in list(graph[u]):
                graph[u].remove(v)
                queue.append(v)

    return [ans if ans != math.inf else -1 for ans in answer]
```

- [1971. Find if Path Exists in Graph](https://leetcode.com/problems/find-if-path-exists-in-graph/)
- [797. All Paths From Source to Target](https://leetcode.com/problems/all-paths-from-source-to-target/)
- [1059. All Paths from Source Lead to Destination](https://leetcode.com/problems/all-paths-from-source-lead-to-destination/)
- [116. Populating Next Right Pointers in Each Node](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/)
- [1091. Shortest Path in Binary Matrix](https://leetcode.com/problems/shortest-path-in-binary-matrix/)
- [429. N-ary Tree Level Order Traversal](https://leetcode.com/problems/n-ary-tree-level-order-traversal/)
- [994. Rotting Oranges](https://leetcode.com/problems/rotting-oranges/)
- [1129. Shortest Path with Alternating Colors](https://leetcode.com/problems/shortest-path-with-alternating-colors/)
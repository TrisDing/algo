# Array

> Array is a linear table data structure. It uses a group of contiguous memory space to store a group of data of the same type.

- Array is best for **random access** (using the address finding formula)
- Array is not efficient for **insertion** or **deletion** (need to move the elements to keep continuity in memory)

| Operation  | Time Complexity |
| ---------- | :-------------: |
| Access     | O(1)            |
| Search     | O(1)            |
| Insertion  | O(n)            |
| Deletion   | O(n)            |

**How to improve Insertion?**

If the array is sorted or we have to keep the element order, we have no choice but to move the existing elements when inserting new element. Otherwise, we can copy the new value to the desired position and insert a new element with the old value in the end of the array. This way, insertion will become `O(1)`.

**How to improve Deletion?**

We can first mark the element as _"deleted"_, so that each delete operation does not trigger element relocation. When the array has no more space to store data, we trigger a real delete operation, which greatly reduces the element movement. This is the same concept of the Java's [Garbage Collection](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html).

**Dynamic Array**

Dynamic Array or Containers such as Java’s [ArrayList](https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/ArrayList.java) or Python’s [List](https://docs.python.org/3/tutorial/datastructures.html#more-on-lists) are dynamically resized, when the array is full, it will try to allocate a new `x1.5` or `x2` size memory and copy all the elements from the existing array to the new one.

## Sequence Operations

Python sequence includes list, tuple, range, etc. Arrays are lists, lists are **mutable** sequences, tuples are **immutable** sequences.

```py
x in s             # True if an item of s is equal to x, else False
x not in s         # False if an item of s is equal to x, else True
s + t              # the concatenation of s and t
s * n or n * s     # equivalent to adding s to itself n times
s[i]               # ith item of s, origin 0
s[i:j]             # slice of s from i to j
s[i:j:k]           # slice of s from i to j with step k
len(s)             # length of s
min(s)             # smallest item of s
max(s)             # largest item of s
reversed(s)        # return a reverse iterator
sorted(s)          # return a new sorted list from the items in iterable
```

## List Operations

```py
a.append(x)        # appends x to the end of the sequence (same as s[len(s):len(s)] = [x])
a.extend(iterable) # extends s with the contents of t (same as s += t)
a.insert(i, x)     # inserts x into s at the index given by i (same as s[i:i] = [x])
a.remove(x)        # remove the first item from s where s[i] is equal to x
a.pop([i])         # retrieves the item at i and also removes it from s
a.clear()          # removes all items from s (same as del s[:])
a.count(x)         # total number of occurrences of x in s
a.reverse()        # reverses the items of s in place
a.copy()           # creates a shallow copy of s (same as s[:])
a.index(x[, start[, end]])      # index of the first occurrence of x in s
a.sort(key=None, reverse=False) # Sort the items of the list in place
```

## Coding Techniques

```py
# List comprehension
vec = [-4, -2, 0, 2, 4]
[x*2 for x in vec] # [-8, -4, 0, 4, 8]
[x for x in vec if x >= 0] # [0, 2, 4]
[abs(x) for x in vec] # [4, 2, 0, 2, 4]

# Create a list of 2-tuples (number, square)
[(x, x**2) for x in range(4)] # [(0, 0), (1, 1), (2, 4), (3, 9)]

# Flatten a 2-D list
vec = [[1,2,3], [4,5,6], [7,8,9]]
[num for elem in vec for num in elem]

# Create a M x N matrix
matrix = [[0] * N for _ in range(M)]

# String formatter
'Hello {name}'.format(name='World')

# Useful functions
filter(lambda x: x % 2 != 0, [1, 2, 3, 4, 5, 6]) # [1, 3, 5]
map(lambda x, y: x + y, [1, 2, 3], [4, 5, 6]) # [5, 7, 9]
any((False, False, True)) # True
all((False, True, True)) # False
sum([1, 2, 3, 4, 5]) # 15

functools.reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) # calculates ((((1+2)+3)+4)+5) = 15
```

## Algorithms

**Print Pairs**
```py
nums = [1,2,3,4]
n = len(nums)
for i in range(n-1):
    for j in range(i+1, n):
        print((nums[i], nums[j])) # [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]
```

**Traverse Backwards**
```py
nums = [1,2,3,4]
n = len(nums)
for i in range(n-1, -1, -1):
    print(nums[i]) # [4,3,2,1]
```

**Fixed window of size k**
```py
nums, k = [1,2,3,4,5,6], 3
n = len(nums)
for i in range(n-k+1):
    window = nums[i:i+k]
    print(window) # [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6]]
```

**Rotate array by k times (right shift)**
```py
nums, k = [1,2,3,4,5,6,7], 3
n = len(nums)
res = [0] * n
for i in range(n):
    res[(i+k)%n] = nums[i]
print(res) # [5,6,7,1,2,3,4]
```

**Two Pointers**
```py
"""
Print the list from start and end in pairs
"""
nums = [1,2,3,4,5,6,7,8,9]
n = len(nums)
i, j = 0, n-1
while i <= j:
    print(nums[i], nums[j]) # [(1, 9), (2, 8), (3, 7), (4, 6), (5, 5)]
    while i <= j and nums[i+1] == nums[i]: i += 1 # skip duplicates
    while i <= j and nums[j-1] == nums[j]: j -= 1 # skip duplicates
    i += 1
    j -= 1
```

**Two Scans**
```py
"""
Get the product of all the numbers in the list except the number itself.
"""
nums = [1,2,3,4]
n = len(nums)
product = []
# scan from left to right
l = 1
for i in range(n):
    product.append(l)
    l *= nums[i]
# scan from right to left and calculate product
r = 1
for i in range(n-1, -1, -1):
    product[i] = product[i] * r
    r *= nums[i]

return product # [24,12,8,6]
```

**Sliding Window**
```py
"""
Minimal length of a contiguous subarray of which the total >= target.
"""
nums = [2,3,1,2,4,3]
target = 7

n = len(nums)
res = math.inf
total = 0

l = 0
for r in range(n): # window expanding
    total += nums[r] # total increase
    while total >= target:
        res = min(res, r+l-1) # window size r+l-1
        total -= nums[l] # total decrease
        l += 1 # window shrinking

return res if res < math.inf else 0 # 2, subarray [4,3] has the min length
```

**Spiral Matrix**
```py
"""
Generate an n x n matrix filled with elements from 1 to n^2 in spiral order.
"""
def floorMod(x, y): # to prevent negative case
    return ((x % y) + y) % y

n = 3
res = [[0]*n for _ in range(n)]
direction = [(0,1), (1,0), (0,-1), (-1,0)] # right, down, left, up
i = j = d = 0
for num in range(n*n):
    res[i][j] = num + 1
    di, dj = direction[d]
    next_i = floorMod(i + di, n)
    next_j = floorMod(j + dj, n)
    if res[next_i][next_j] != 0: # this slot has been calculated
        d = (d+1) % 4 # change directions
    # move on to the next one
    di, dj = direction[d]
    i += di
    j += dj

return res
# [
#   [1, 2, 3],
#   [8, 9, 4],
#   [7, 6, 5]
# ]
```

## Leetcode Problems

- [283. Move Zeroes](https://leetcode.com/problems/move-zeroes/)
- [26. Remove Duplicates from Sorted Array ](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)
- [27. Remove Element](https://leetcode.com/problems/remove-element/)
- [66. Plus One](https://leetcode.com/problems/plus-one/)
- [1. Two Sum](https://leetcode.com/problems/two-sum/)
- [88. Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/)
- [189. Rotate Array](https://leetcode.com/problems/rotate-array/)
- [977. Squares of a Sorted Array](https://leetcode.com/problems/squares-of-a-sorted-array/)
- [209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/)
- [15. 3Sum](https://leetcode.com/problems/3sum/)
- [11. Container With Most Water](https://leetcode.com/problems/container-with-most-water/)
- [59. Spiral Matrix II](https://leetcode.com/problems/spiral-matrix-ii/)